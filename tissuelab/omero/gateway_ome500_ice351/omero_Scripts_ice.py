# **********************************************************************
#
# Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************
#
# Ice version 3.5.1
#
# <auto-generated>
#
# Generated from file `Scripts.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice, IcePy
import omero_RTypes_ice
import omero_System_ice
import omero_ServerErrors_ice
import omero_Collections_ice

# Included module omero
_M_omero = Ice.openModule('omero')

# Included module omero.model
_M_omero.model = Ice.openModule('omero.model')

# Included module Ice
_M_Ice = Ice.openModule('Ice')

# Included module omero.sys
_M_omero.sys = Ice.openModule('omero.sys')

# Included module Glacier2
_M_Glacier2 = Ice.openModule('Glacier2')

# Included module omero.api
_M_omero.api = Ice.openModule('omero.api')

# Start of module omero
__name__ = 'omero'

if 'Internal' not in _M_omero.__dict__:
    _M_omero.Internal = Ice.createTempClass()
    class Internal(Ice.Object):
        '''Base class similar to [omero::model::IObject] but for non-model-objects.'''
        def __init__(self):
            pass

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::Internal')

        def ice_id(self, current=None):
            return '::omero::Internal'

        def ice_staticId():
            return '::omero::Internal'
        ice_staticId = staticmethod(ice_staticId)

        def __str__(self):
            return IcePy.stringify(self, _M_omero._t_Internal)

        __repr__ = __str__

    _M_omero.InternalPrx = Ice.createTempClass()
    class InternalPrx(Ice.ObjectPrx):

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.InternalPrx.ice_checkedCast(proxy, '::omero::Internal', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.InternalPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero._t_InternalPrx = IcePy.defineProxy('::omero::Internal', InternalPrx)

    _M_omero._t_Internal = IcePy.defineClass('::omero::Internal', Internal, -1, (), False, False, None, (), ())
    Internal._ice_type = _M_omero._t_Internal

    _M_omero.Internal = Internal
    del Internal

    _M_omero.InternalPrx = InternalPrx
    del InternalPrx

if 'RInternal' not in _M_omero.__dict__:
    _M_omero.RInternal = Ice.createTempClass()
    class RInternal(_M_omero.RType):
        '''Base type for [RType]s whose contents will not be parsed by
the server. This allows Blitz-specific types to be safely
passed in as the inputs/outputs of scripts.'''
        def __init__(self, _val=None):
            if Ice.getType(self) == _M_omero.RInternal:
                raise RuntimeError('omero.RInternal is an abstract class')
            _M_omero.RType.__init__(self)
            self._val = _val

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::RInternal', '::omero::RType')

        def ice_id(self, current=None):
            return '::omero::RInternal'

        def ice_staticId():
            return '::omero::RInternal'
        ice_staticId = staticmethod(ice_staticId)

        def getValue(self, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_omero._t_RInternal)

        __repr__ = __str__

    _M_omero.RInternalPrx = Ice.createTempClass()
    class RInternalPrx(_M_omero.RTypePrx):

        def getValue(self, _ctx=None):
            return _M_omero.RInternal._op_getValue.invoke(self, ((), _ctx))

        def begin_getValue(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.RInternal._op_getValue.begin(self, ((), _response, _ex, _sent, _ctx))

        def end_getValue(self, _r):
            return _M_omero.RInternal._op_getValue.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.RInternalPrx.ice_checkedCast(proxy, '::omero::RInternal', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.RInternalPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero._t_RInternalPrx = IcePy.defineProxy('::omero::RInternal', RInternalPrx)

    _M_omero._t_RInternal = IcePy.declareClass('::omero::RInternal')

    _M_omero._t_RInternal = IcePy.defineClass('::omero::RInternal', RInternal, -1, (), True, False, _M_omero._t_RType, (), (('_val', (), _M_omero._t_Internal, False, 0),))
    RInternal._ice_type = _M_omero._t_RInternal

    RInternal._op_getValue = IcePy.Operation('getValue', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_omero._t_Internal, False, 0), ())

    _M_omero.RInternal = RInternal
    del RInternal

    _M_omero.RInternalPrx = RInternalPrx
    del RInternalPrx

if '_t_Bytes2D' not in _M_omero.__dict__:
    _M_omero._t_Bytes2D = IcePy.defineSequence('::omero::Bytes2D', (), _M_Ice._t_ByteSeq)

if 'Plane' not in _M_omero.__dict__:
    _M_omero.Plane = Ice.createTempClass()
    class Plane(_M_omero.Internal):
        '''Sequences cannot subclass other types, so the Plane
class extends [Internal] and wraps a [Bytes2D] instance.'''
        def __init__(self, data=None):
            _M_omero.Internal.__init__(self)
            self.data = data

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::Internal', '::omero::Plane')

        def ice_id(self, current=None):
            return '::omero::Plane'

        def ice_staticId():
            return '::omero::Plane'
        ice_staticId = staticmethod(ice_staticId)

        def __str__(self):
            return IcePy.stringify(self, _M_omero._t_Plane)

        __repr__ = __str__

    _M_omero.PlanePrx = Ice.createTempClass()
    class PlanePrx(_M_omero.InternalPrx):

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.PlanePrx.ice_checkedCast(proxy, '::omero::Plane', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.PlanePrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero._t_PlanePrx = IcePy.defineProxy('::omero::Plane', PlanePrx)

    _M_omero._t_Plane = IcePy.defineClass('::omero::Plane', Plane, -1, (), False, False, _M_omero._t_Internal, (), (('data', (), _M_omero._t_Bytes2D, False, 0),))
    Plane._ice_type = _M_omero._t_Plane

    _M_omero.Plane = Plane
    del Plane

    _M_omero.PlanePrx = PlanePrx
    del PlanePrx

if 'Point' not in _M_omero.__dict__:
    _M_omero.Point = Ice.createTempClass()
    class Point(_M_omero.Internal):
        '''XY-point in space.'''
        def __init__(self, x=0, y=0):
            _M_omero.Internal.__init__(self)
            self.x = x
            self.y = y

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::Internal', '::omero::Point')

        def ice_id(self, current=None):
            return '::omero::Point'

        def ice_staticId():
            return '::omero::Point'
        ice_staticId = staticmethod(ice_staticId)

        def __str__(self):
            return IcePy.stringify(self, _M_omero._t_Point)

        __repr__ = __str__

    _M_omero.PointPrx = Ice.createTempClass()
    class PointPrx(_M_omero.InternalPrx):

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.PointPrx.ice_checkedCast(proxy, '::omero::Point', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.PointPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero._t_PointPrx = IcePy.defineProxy('::omero::Point', PointPrx)

    _M_omero._t_Point = IcePy.defineClass('::omero::Point', Point, -1, (), False, False, _M_omero._t_Internal, (), (
        ('x', (), IcePy._t_int, False, 0),
        ('y', (), IcePy._t_int, False, 0)
    ))
    Point._ice_type = _M_omero._t_Point

    _M_omero.Point = Point
    del Point

    _M_omero.PointPrx = PointPrx
    del PointPrx

if 'Color' not in _M_omero.__dict__:
    _M_omero.Color = Ice.createTempClass()
    class Color(_M_omero.Internal):
        '''RGBA-color packed into a single long.'''
        def __init__(self, packedColor=0):
            _M_omero.Internal.__init__(self)
            self.packedColor = packedColor

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::Color', '::omero::Internal')

        def ice_id(self, current=None):
            return '::omero::Color'

        def ice_staticId():
            return '::omero::Color'
        ice_staticId = staticmethod(ice_staticId)

        def __str__(self):
            return IcePy.stringify(self, _M_omero._t_Color)

        __repr__ = __str__

    _M_omero.ColorPrx = Ice.createTempClass()
    class ColorPrx(_M_omero.InternalPrx):

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.ColorPrx.ice_checkedCast(proxy, '::omero::Color', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.ColorPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero._t_ColorPrx = IcePy.defineProxy('::omero::Color', ColorPrx)

    _M_omero._t_Color = IcePy.defineClass('::omero::Color', Color, -1, (), False, False, _M_omero._t_Internal, (), (('packedColor', (), IcePy._t_long, False, 0),))
    Color._ice_type = _M_omero._t_Color

    _M_omero.Color = Color
    del Color

    _M_omero.ColorPrx = ColorPrx
    del ColorPrx

# Start of module omero.grid
_M_omero.grid = Ice.openModule('omero.grid')
__name__ = 'omero.grid'

if 'Param' not in _M_omero.grid.__dict__:
    _M_omero.grid.Param = Ice.createTempClass()
    class Param(Ice.Object):
        '''A single parameter to a Job. For example, used by
ScriptJobs to define what the input and output
environment variables should be. Helper classes are available
in the Python omero.scripts module, so that the following are
equivalent:

# 1
a = omero.grid.Params()
a.optional = True
a.prototype = omero.rtypes.rstring("")
a.description = "An optional string which will be ignored by the script"
omero.scripts.client(inputs = {"a":a})

# 2
a = omero.scripts.String("a", optional=True, description=         * "An optional string which will be ignored by the script")
omero.scripts.client(a)

For advanced setters not available on the Type classes (like omero.script.String)
use the getter type.param() and then set values directly.

a = omero.scripts.String("a")
a.param().values = ["hi", "bye"]'''
        def __init__(self, description='', optional=False, useDefault=False, prototype=None, min=None, max=None, values=None, grouping='', namespaces=None):
            self.description = description
            self.optional = optional
            self.useDefault = useDefault
            self.prototype = prototype
            self.min = min
            self.max = max
            self.values = values
            self.grouping = grouping
            self.namespaces = namespaces

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::grid::Param')

        def ice_id(self, current=None):
            return '::omero::grid::Param'

        def ice_staticId():
            return '::omero::grid::Param'
        ice_staticId = staticmethod(ice_staticId)

        def __str__(self):
            return IcePy.stringify(self, _M_omero.grid._t_Param)

        __repr__ = __str__

    _M_omero.grid.ParamPrx = Ice.createTempClass()
    class ParamPrx(Ice.ObjectPrx):

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.grid.ParamPrx.ice_checkedCast(proxy, '::omero::grid::Param', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.grid.ParamPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero.grid._t_ParamPrx = IcePy.defineProxy('::omero::grid::Param', ParamPrx)

    _M_omero.grid._t_Param = IcePy.declareClass('::omero::grid::Param')

    _M_omero.grid._t_Param = IcePy.defineClass('::omero::grid::Param', Param, -1, (), False, False, None, (), (
        ('description', (), IcePy._t_string, False, 0),
        ('optional', (), IcePy._t_bool, False, 0),
        ('useDefault', (), IcePy._t_bool, False, 0),
        ('prototype', (), _M_omero._t_RType, False, 0),
        ('min', (), _M_omero._t_RType, False, 0),
        ('max', (), _M_omero._t_RType, False, 0),
        ('values', (), _M_omero._t_RList, False, 0),
        ('grouping', (), IcePy._t_string, False, 0),
        ('namespaces', (), _M_omero.api._t_StringSet, False, 0)
    ))
    Param._ice_type = _M_omero.grid._t_Param

    _M_omero.grid.Param = Param
    del Param

    _M_omero.grid.ParamPrx = ParamPrx
    del ParamPrx

if '_t_ParamMap' not in _M_omero.grid.__dict__:
    _M_omero.grid._t_ParamMap = IcePy.defineDictionary('::omero::grid::ParamMap', (), IcePy._t_string, _M_omero.grid._t_Param)

if 'JobParams' not in _M_omero.grid.__dict__:
    _M_omero.grid.JobParams = Ice.createTempClass()
    class JobParams(_M_omero.Internal):
        '''Complete job description with all input and output Params.

JobParams contain information about who wrote a script, what its
purpose is, and how it should be used, and are defined via the
"omero.scripts.client" method.

c = omero.scripts.client(name="my algorithm", version="0.0.1")

Alternatively, a JobParams instance can be passed into the constructor:

params = omero.grid.JobParams()
params.authors = ["Andy", "Kathy"]
params.version = "0.0.1"
params.description = """
Clever way to count to 5
"""
c = omero.scripts.client(params)

A single JobParam instance is parsed from a script and stored by the server.
Later invocations re-use this instance until the script changes.'''
        def __init__(self, name='', version='', description='', contact='', authors=None, institutions=None, authorsInstitutions=None, inputs=None, outputs=None, stdoutFormat='', stderrFormat='', namespaces=None):
            _M_omero.Internal.__init__(self)
            self.name = name
            self.version = version
            self.description = description
            self.contact = contact
            self.authors = authors
            self.institutions = institutions
            self.authorsInstitutions = authorsInstitutions
            self.inputs = inputs
            self.outputs = outputs
            self.stdoutFormat = stdoutFormat
            self.stderrFormat = stderrFormat
            self.namespaces = namespaces

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::Internal', '::omero::grid::JobParams')

        def ice_id(self, current=None):
            return '::omero::grid::JobParams'

        def ice_staticId():
            return '::omero::grid::JobParams'
        ice_staticId = staticmethod(ice_staticId)

        def __str__(self):
            return IcePy.stringify(self, _M_omero.grid._t_JobParams)

        __repr__ = __str__

    _M_omero.grid.JobParamsPrx = Ice.createTempClass()
    class JobParamsPrx(_M_omero.InternalPrx):

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.grid.JobParamsPrx.ice_checkedCast(proxy, '::omero::grid::JobParams', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.grid.JobParamsPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero.grid._t_JobParamsPrx = IcePy.defineProxy('::omero::grid::JobParams', JobParamsPrx)

    _M_omero.grid._t_JobParams = IcePy.declareClass('::omero::grid::JobParams')

    _M_omero.grid._t_JobParams = IcePy.defineClass('::omero::grid::JobParams', JobParams, -1, (), False, False, _M_omero._t_Internal, (), (
        ('name', (), IcePy._t_string, False, 0),
        ('version', (), IcePy._t_string, False, 0),
        ('description', (), IcePy._t_string, False, 0),
        ('contact', (), IcePy._t_string, False, 0),
        ('authors', (), _M_omero.api._t_StringArray, False, 0),
        ('institutions', (), _M_omero.api._t_StringArray, False, 0),
        ('authorsInstitutions', (), _M_omero.api._t_IntegerArrayArray, False, 0),
        ('inputs', (), _M_omero.grid._t_ParamMap, False, 0),
        ('outputs', (), _M_omero.grid._t_ParamMap, False, 0),
        ('stdoutFormat', (), IcePy._t_string, False, 0),
        ('stderrFormat', (), IcePy._t_string, False, 0),
        ('namespaces', (), _M_omero.api._t_StringSet, False, 0)
    ))
    JobParams._ice_type = _M_omero.grid._t_JobParams

    _M_omero.grid.JobParams = JobParams
    del JobParams

    _M_omero.grid.JobParamsPrx = JobParamsPrx
    del JobParamsPrx

if 'ProcessCallback' not in _M_omero.grid.__dict__:
    _M_omero.grid.ProcessCallback = Ice.createTempClass()
    class ProcessCallback(Ice.Object):
        '''Callback which can be attached to a Process
with notification of any of the possible
ends-of-life that a Process might experience'''
        def __init__(self):
            if Ice.getType(self) == _M_omero.grid.ProcessCallback:
                raise RuntimeError('omero.grid.ProcessCallback is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::grid::ProcessCallback')

        def ice_id(self, current=None):
            return '::omero::grid::ProcessCallback'

        def ice_staticId():
            return '::omero::grid::ProcessCallback'
        ice_staticId = staticmethod(ice_staticId)

        def processFinished(self, returncode, current=None):
            '''Process terminated normally. Return code provided.
In the case that a non-Blitz process sent a signal
(KILL, TERM, ... ), that will represented in the
return code.'''
            pass

        def processCancelled(self, success, current=None):
            '''cancel() was called on this Process. If the Process
failed to terminate, argument is false, in which calling
kill() is the last resort.'''
            pass

        def processKilled(self, success, current=None):
            '''kill() was called on this Process. If this does not
succeed, there is nothing else that Blitz can do to
stop its execution.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_omero.grid._t_ProcessCallback)

        __repr__ = __str__

    _M_omero.grid.ProcessCallbackPrx = Ice.createTempClass()
    class ProcessCallbackPrx(Ice.ObjectPrx):

        '''Process terminated normally. Return code provided.
In the case that a non-Blitz process sent a signal
(KILL, TERM, ... ), that will represented in the
return code.'''
        def processFinished(self, returncode, _ctx=None):
            return _M_omero.grid.ProcessCallback._op_processFinished.invoke(self, ((returncode, ), _ctx))

        '''Process terminated normally. Return code provided.
In the case that a non-Blitz process sent a signal
(KILL, TERM, ... ), that will represented in the
return code.'''
        def begin_processFinished(self, returncode, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.ProcessCallback._op_processFinished.begin(self, ((returncode, ), _response, _ex, _sent, _ctx))

        '''Process terminated normally. Return code provided.
In the case that a non-Blitz process sent a signal
(KILL, TERM, ... ), that will represented in the
return code.'''
        def end_processFinished(self, _r):
            return _M_omero.grid.ProcessCallback._op_processFinished.end(self, _r)

        '''Process terminated normally. Return code provided.
In the case that a non-Blitz process sent a signal
(KILL, TERM, ... ), that will represented in the
return code.'''
        def processFinished_async(self, _cb, returncode, _ctx=None):
            return _M_omero.grid.ProcessCallback._op_processFinished.invokeAsync(self, (_cb, (returncode, ), _ctx))

        '''cancel() was called on this Process. If the Process
failed to terminate, argument is false, in which calling
kill() is the last resort.'''
        def processCancelled(self, success, _ctx=None):
            return _M_omero.grid.ProcessCallback._op_processCancelled.invoke(self, ((success, ), _ctx))

        '''cancel() was called on this Process. If the Process
failed to terminate, argument is false, in which calling
kill() is the last resort.'''
        def begin_processCancelled(self, success, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.ProcessCallback._op_processCancelled.begin(self, ((success, ), _response, _ex, _sent, _ctx))

        '''cancel() was called on this Process. If the Process
failed to terminate, argument is false, in which calling
kill() is the last resort.'''
        def end_processCancelled(self, _r):
            return _M_omero.grid.ProcessCallback._op_processCancelled.end(self, _r)

        '''cancel() was called on this Process. If the Process
failed to terminate, argument is false, in which calling
kill() is the last resort.'''
        def processCancelled_async(self, _cb, success, _ctx=None):
            return _M_omero.grid.ProcessCallback._op_processCancelled.invokeAsync(self, (_cb, (success, ), _ctx))

        '''kill() was called on this Process. If this does not
succeed, there is nothing else that Blitz can do to
stop its execution.'''
        def processKilled(self, success, _ctx=None):
            return _M_omero.grid.ProcessCallback._op_processKilled.invoke(self, ((success, ), _ctx))

        '''kill() was called on this Process. If this does not
succeed, there is nothing else that Blitz can do to
stop its execution.'''
        def begin_processKilled(self, success, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.ProcessCallback._op_processKilled.begin(self, ((success, ), _response, _ex, _sent, _ctx))

        '''kill() was called on this Process. If this does not
succeed, there is nothing else that Blitz can do to
stop its execution.'''
        def end_processKilled(self, _r):
            return _M_omero.grid.ProcessCallback._op_processKilled.end(self, _r)

        '''kill() was called on this Process. If this does not
succeed, there is nothing else that Blitz can do to
stop its execution.'''
        def processKilled_async(self, _cb, success, _ctx=None):
            return _M_omero.grid.ProcessCallback._op_processKilled.invokeAsync(self, (_cb, (success, ), _ctx))

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.grid.ProcessCallbackPrx.ice_checkedCast(proxy, '::omero::grid::ProcessCallback', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.grid.ProcessCallbackPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero.grid._t_ProcessCallbackPrx = IcePy.defineProxy('::omero::grid::ProcessCallback', ProcessCallbackPrx)

    _M_omero.grid._t_ProcessCallback = IcePy.defineClass('::omero::grid::ProcessCallback', ProcessCallback, -1, (), True, False, None, (), ())
    ProcessCallback._ice_type = _M_omero.grid._t_ProcessCallback

    ProcessCallback._op_processFinished = IcePy.Operation('processFinished', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0),), (), None, ())
    ProcessCallback._op_processCancelled = IcePy.Operation('processCancelled', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_bool, False, 0),), (), None, ())
    ProcessCallback._op_processKilled = IcePy.Operation('processKilled', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_bool, False, 0),), (), None, ())

    _M_omero.grid.ProcessCallback = ProcessCallback
    del ProcessCallback

    _M_omero.grid.ProcessCallbackPrx = ProcessCallbackPrx
    del ProcessCallbackPrx

if 'Process' not in _M_omero.grid.__dict__:
    _M_omero.grid.Process = Ice.createTempClass()
    class Process(Ice.Object):
        '''Thin wrapper around a system-level process. Most closely
resembles Python's subprocess.Popen class.'''
        def __init__(self):
            if Ice.getType(self) == _M_omero.grid.Process:
                raise RuntimeError('omero.grid.Process is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::grid::Process')

        def ice_id(self, current=None):
            return '::omero::grid::Process'

        def ice_staticId():
            return '::omero::grid::Process'
        ice_staticId = staticmethod(ice_staticId)

        def poll(self, current=None):
            '''Returns the return code of the process, or null
if unfinished.'''
            pass

        def wait(self, current=None):
            '''Blocks until poll() would return a non-null return code.'''
            pass

        def cancel(self, current=None):
            '''Signal to the Process that it should terminate. This may
be done "softly" for a given time period.'''
            pass

        def kill(self, current=None):
            '''Terminate the Process immediately.'''
            pass

        def shutdown(self, current=None):
            '''First attempts cancel() several times and finally
resorts to kill to force the process to shutdown
cleanly. This method doesn't return any value or
throw an exception so that it can be called oneway.'''
            pass

        def registerCallback(self, cb, current=None):
            '''Add a callback for end-of-life events'''
            pass

        def unregisterCallback(self, cb, current=None):
            '''Remove a callback for end-of-life events'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_omero.grid._t_Process)

        __repr__ = __str__

    _M_omero.grid.ProcessPrx = Ice.createTempClass()
    class ProcessPrx(Ice.ObjectPrx):

        '''Returns the return code of the process, or null
if unfinished.'''
        def poll(self, _ctx=None):
            return _M_omero.grid.Process._op_poll.invoke(self, ((), _ctx))

        '''Returns the return code of the process, or null
if unfinished.'''
        def begin_poll(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.Process._op_poll.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Returns the return code of the process, or null
if unfinished.'''
        def end_poll(self, _r):
            return _M_omero.grid.Process._op_poll.end(self, _r)

        '''Returns the return code of the process, or null
if unfinished.'''
        def poll_async(self, _cb, _ctx=None):
            return _M_omero.grid.Process._op_poll.invokeAsync(self, (_cb, (), _ctx))

        '''Blocks until poll() would return a non-null return code.'''
        def wait(self, _ctx=None):
            return _M_omero.grid.Process._op_wait.invoke(self, ((), _ctx))

        '''Blocks until poll() would return a non-null return code.'''
        def begin_wait(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.Process._op_wait.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Blocks until poll() would return a non-null return code.'''
        def end_wait(self, _r):
            return _M_omero.grid.Process._op_wait.end(self, _r)

        '''Blocks until poll() would return a non-null return code.'''
        def wait_async(self, _cb, _ctx=None):
            return _M_omero.grid.Process._op_wait.invokeAsync(self, (_cb, (), _ctx))

        '''Signal to the Process that it should terminate. This may
be done "softly" for a given time period.'''
        def cancel(self, _ctx=None):
            return _M_omero.grid.Process._op_cancel.invoke(self, ((), _ctx))

        '''Signal to the Process that it should terminate. This may
be done "softly" for a given time period.'''
        def begin_cancel(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.Process._op_cancel.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Signal to the Process that it should terminate. This may
be done "softly" for a given time period.'''
        def end_cancel(self, _r):
            return _M_omero.grid.Process._op_cancel.end(self, _r)

        '''Signal to the Process that it should terminate. This may
be done "softly" for a given time period.'''
        def cancel_async(self, _cb, _ctx=None):
            return _M_omero.grid.Process._op_cancel.invokeAsync(self, (_cb, (), _ctx))

        '''Terminate the Process immediately.'''
        def kill(self, _ctx=None):
            return _M_omero.grid.Process._op_kill.invoke(self, ((), _ctx))

        '''Terminate the Process immediately.'''
        def begin_kill(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.Process._op_kill.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Terminate the Process immediately.'''
        def end_kill(self, _r):
            return _M_omero.grid.Process._op_kill.end(self, _r)

        '''Terminate the Process immediately.'''
        def kill_async(self, _cb, _ctx=None):
            return _M_omero.grid.Process._op_kill.invokeAsync(self, (_cb, (), _ctx))

        '''First attempts cancel() several times and finally
resorts to kill to force the process to shutdown
cleanly. This method doesn't return any value or
throw an exception so that it can be called oneway.'''
        def shutdown(self, _ctx=None):
            return _M_omero.grid.Process._op_shutdown.invoke(self, ((), _ctx))

        '''First attempts cancel() several times and finally
resorts to kill to force the process to shutdown
cleanly. This method doesn't return any value or
throw an exception so that it can be called oneway.'''
        def begin_shutdown(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.Process._op_shutdown.begin(self, ((), _response, _ex, _sent, _ctx))

        '''First attempts cancel() several times and finally
resorts to kill to force the process to shutdown
cleanly. This method doesn't return any value or
throw an exception so that it can be called oneway.'''
        def end_shutdown(self, _r):
            return _M_omero.grid.Process._op_shutdown.end(self, _r)

        '''First attempts cancel() several times and finally
resorts to kill to force the process to shutdown
cleanly. This method doesn't return any value or
throw an exception so that it can be called oneway.'''
        def shutdown_async(self, _cb, _ctx=None):
            return _M_omero.grid.Process._op_shutdown.invokeAsync(self, (_cb, (), _ctx))

        '''Add a callback for end-of-life events'''
        def registerCallback(self, cb, _ctx=None):
            return _M_omero.grid.Process._op_registerCallback.invoke(self, ((cb, ), _ctx))

        '''Add a callback for end-of-life events'''
        def begin_registerCallback(self, cb, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.Process._op_registerCallback.begin(self, ((cb, ), _response, _ex, _sent, _ctx))

        '''Add a callback for end-of-life events'''
        def end_registerCallback(self, _r):
            return _M_omero.grid.Process._op_registerCallback.end(self, _r)

        '''Add a callback for end-of-life events'''
        def registerCallback_async(self, _cb, cb, _ctx=None):
            return _M_omero.grid.Process._op_registerCallback.invokeAsync(self, (_cb, (cb, ), _ctx))

        '''Remove a callback for end-of-life events'''
        def unregisterCallback(self, cb, _ctx=None):
            return _M_omero.grid.Process._op_unregisterCallback.invoke(self, ((cb, ), _ctx))

        '''Remove a callback for end-of-life events'''
        def begin_unregisterCallback(self, cb, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.Process._op_unregisterCallback.begin(self, ((cb, ), _response, _ex, _sent, _ctx))

        '''Remove a callback for end-of-life events'''
        def end_unregisterCallback(self, _r):
            return _M_omero.grid.Process._op_unregisterCallback.end(self, _r)

        '''Remove a callback for end-of-life events'''
        def unregisterCallback_async(self, _cb, cb, _ctx=None):
            return _M_omero.grid.Process._op_unregisterCallback.invokeAsync(self, (_cb, (cb, ), _ctx))

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.grid.ProcessPrx.ice_checkedCast(proxy, '::omero::grid::Process', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.grid.ProcessPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero.grid._t_ProcessPrx = IcePy.defineProxy('::omero::grid::Process', ProcessPrx)

    _M_omero.grid._t_Process = IcePy.defineClass('::omero::grid::Process', Process, -1, (), True, False, None, (), ())
    Process._ice_type = _M_omero.grid._t_Process

    Process._op_poll = IcePy.Operation('poll', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_omero._t_RInt, False, 0), (_M_omero._t_ServerError,))
    Process._op_wait = IcePy.Operation('wait', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_int, False, 0), (_M_omero._t_ServerError,))
    Process._op_cancel = IcePy.Operation('cancel', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_bool, False, 0), (_M_omero._t_ServerError,))
    Process._op_kill = IcePy.Operation('kill', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_bool, False, 0), ())
    Process._op_shutdown = IcePy.Operation('shutdown', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, ())
    Process._op_registerCallback = IcePy.Operation('registerCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_omero.grid._t_ProcessCallbackPrx, False, 0),), (), None, (_M_omero._t_ServerError,))
    Process._op_unregisterCallback = IcePy.Operation('unregisterCallback', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_omero.grid._t_ProcessCallbackPrx, False, 0),), (), None, (_M_omero._t_ServerError,))

    _M_omero.grid.Process = Process
    del Process

    _M_omero.grid.ProcessPrx = ProcessPrx
    del ProcessPrx

if 'ScriptProcess' not in _M_omero.grid.__dict__:
    _M_omero.grid.ScriptProcess = Ice.createTempClass()
    class ScriptProcess(_M_omero.grid.Process):
        '''Extension of the [Process] interface which is returned by [IScript]
when an [omero::model::ScriptJob] is launched. It is critical that
instances of [ScriptProcess] are closed on completetion. See the close
method for more information.'''
        def __init__(self):
            if Ice.getType(self) == _M_omero.grid.ScriptProcess:
                raise RuntimeError('omero.grid.ScriptProcess is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::grid::Process', '::omero::grid::ScriptProcess')

        def ice_id(self, current=None):
            return '::omero::grid::ScriptProcess'

        def ice_staticId():
            return '::omero::grid::ScriptProcess'
        ice_staticId = staticmethod(ice_staticId)

        def getJob(self, current=None):
            '''Returns the job which started this process. Several
scheduling fields (submitted, scheduledFor, started, finished)
may be of interest.'''
            pass

        def getResults(self, waitSecs, current=None):
            '''Returns the results immediately if present. If the process
is not yet finished, waits "waitSecs" before throwing an
[omero.ApiUsageException]. If poll has returned a non-null
value, then this method will always return a non-null value.'''
            pass

        def setMessage(self, message, current=None):
            '''Sets the message on the [omero::model::ScriptJob] object.
This value MAY be overwritten by the server if the script
fails.'''
            pass

        def close(self, detach, current=None):
            '''Closes this process and frees server resources attached to it.
If the detach argument is True, then the background process
will continue executing. The user can reconnect to the process
via the [IScript] service.

If the detach argument is False, then the background process
will be shutdown immediately, and all intermediate results
(stdout, stderr, ...) will be uploaded.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_omero.grid._t_ScriptProcess)

        __repr__ = __str__

    _M_omero.grid.ScriptProcessPrx = Ice.createTempClass()
    class ScriptProcessPrx(_M_omero.grid.ProcessPrx):

        '''Returns the job which started this process. Several
scheduling fields (submitted, scheduledFor, started, finished)
may be of interest.'''
        def getJob(self, _ctx=None):
            return _M_omero.grid.ScriptProcess._op_getJob.invoke(self, ((), _ctx))

        '''Returns the job which started this process. Several
scheduling fields (submitted, scheduledFor, started, finished)
may be of interest.'''
        def begin_getJob(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.ScriptProcess._op_getJob.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Returns the job which started this process. Several
scheduling fields (submitted, scheduledFor, started, finished)
may be of interest.'''
        def end_getJob(self, _r):
            return _M_omero.grid.ScriptProcess._op_getJob.end(self, _r)

        '''Returns the results immediately if present. If the process
is not yet finished, waits "waitSecs" before throwing an
[omero.ApiUsageException]. If poll has returned a non-null
value, then this method will always return a non-null value.'''
        def getResults(self, waitSecs, _ctx=None):
            return _M_omero.grid.ScriptProcess._op_getResults.invoke(self, ((waitSecs, ), _ctx))

        '''Returns the results immediately if present. If the process
is not yet finished, waits "waitSecs" before throwing an
[omero.ApiUsageException]. If poll has returned a non-null
value, then this method will always return a non-null value.'''
        def begin_getResults(self, waitSecs, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.ScriptProcess._op_getResults.begin(self, ((waitSecs, ), _response, _ex, _sent, _ctx))

        '''Returns the results immediately if present. If the process
is not yet finished, waits "waitSecs" before throwing an
[omero.ApiUsageException]. If poll has returned a non-null
value, then this method will always return a non-null value.'''
        def end_getResults(self, _r):
            return _M_omero.grid.ScriptProcess._op_getResults.end(self, _r)

        '''Sets the message on the [omero::model::ScriptJob] object.
This value MAY be overwritten by the server if the script
fails.'''
        def setMessage(self, message, _ctx=None):
            return _M_omero.grid.ScriptProcess._op_setMessage.invoke(self, ((message, ), _ctx))

        '''Sets the message on the [omero::model::ScriptJob] object.
This value MAY be overwritten by the server if the script
fails.'''
        def begin_setMessage(self, message, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.ScriptProcess._op_setMessage.begin(self, ((message, ), _response, _ex, _sent, _ctx))

        '''Sets the message on the [omero::model::ScriptJob] object.
This value MAY be overwritten by the server if the script
fails.'''
        def end_setMessage(self, _r):
            return _M_omero.grid.ScriptProcess._op_setMessage.end(self, _r)

        '''Closes this process and frees server resources attached to it.
If the detach argument is True, then the background process
will continue executing. The user can reconnect to the process
via the [IScript] service.

If the detach argument is False, then the background process
will be shutdown immediately, and all intermediate results
(stdout, stderr, ...) will be uploaded.'''
        def close(self, detach, _ctx=None):
            return _M_omero.grid.ScriptProcess._op_close.invoke(self, ((detach, ), _ctx))

        '''Closes this process and frees server resources attached to it.
If the detach argument is True, then the background process
will continue executing. The user can reconnect to the process
via the [IScript] service.

If the detach argument is False, then the background process
will be shutdown immediately, and all intermediate results
(stdout, stderr, ...) will be uploaded.'''
        def begin_close(self, detach, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.ScriptProcess._op_close.begin(self, ((detach, ), _response, _ex, _sent, _ctx))

        '''Closes this process and frees server resources attached to it.
If the detach argument is True, then the background process
will continue executing. The user can reconnect to the process
via the [IScript] service.

If the detach argument is False, then the background process
will be shutdown immediately, and all intermediate results
(stdout, stderr, ...) will be uploaded.'''
        def end_close(self, _r):
            return _M_omero.grid.ScriptProcess._op_close.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.grid.ScriptProcessPrx.ice_checkedCast(proxy, '::omero::grid::ScriptProcess', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.grid.ScriptProcessPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero.grid._t_ScriptProcessPrx = IcePy.defineProxy('::omero::grid::ScriptProcess', ScriptProcessPrx)

    _M_omero.grid._t_ScriptProcess = IcePy.defineClass('::omero::grid::ScriptProcess', ScriptProcess, -1, (), True, False, None, (_M_omero.grid._t_Process,), ())
    ScriptProcess._ice_type = _M_omero.grid._t_ScriptProcess

    ScriptProcess._op_getJob = IcePy.Operation('getJob', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_omero.model._t_ScriptJob, False, 0), (_M_omero._t_ServerError,))
    ScriptProcess._op_getResults = IcePy.Operation('getResults', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_int, False, 0),), (), ((), _M_omero._t_RTypeDict, False, 0), (_M_omero._t_ServerError,))
    ScriptProcess._op_setMessage = IcePy.Operation('setMessage', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0),), (), ((), IcePy._t_string, False, 0), (_M_omero._t_ServerError,))
    ScriptProcess._op_close = IcePy.Operation('close', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_bool, False, 0),), (), None, (_M_omero._t_ServerError,))

    _M_omero.grid.ScriptProcess = ScriptProcess
    del ScriptProcess

    _M_omero.grid.ScriptProcessPrx = ScriptProcessPrx
    del ScriptProcessPrx

if 'ProcessorCallback' not in _M_omero.grid.__dict__:
    _M_omero.grid.ProcessorCallback = Ice.createTempClass()
    class ProcessorCallback(Ice.Object):
        '''Internal callback interface which is passed to the [Processor::accepts] method
to query whether or not a processor will accept a certain operation.'''
        def __init__(self):
            if Ice.getType(self) == _M_omero.grid.ProcessorCallback:
                raise RuntimeError('omero.grid.ProcessorCallback is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::grid::ProcessorCallback')

        def ice_id(self, current=None):
            return '::omero::grid::ProcessorCallback'

        def ice_staticId():
            return '::omero::grid::ProcessorCallback'
        ice_staticId = staticmethod(ice_staticId)

        def isAccepted(self, accepted, sessionUuid, processorConn, current=None):
            pass

        def responseRunning(self, jobIds, current=None):
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_omero.grid._t_ProcessorCallback)

        __repr__ = __str__

    _M_omero.grid.ProcessorCallbackPrx = Ice.createTempClass()
    class ProcessorCallbackPrx(Ice.ObjectPrx):

        def isAccepted(self, accepted, sessionUuid, processorConn, _ctx=None):
            return _M_omero.grid.ProcessorCallback._op_isAccepted.invoke(self, ((accepted, sessionUuid, processorConn), _ctx))

        def begin_isAccepted(self, accepted, sessionUuid, processorConn, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.ProcessorCallback._op_isAccepted.begin(self, ((accepted, sessionUuid, processorConn), _response, _ex, _sent, _ctx))

        def end_isAccepted(self, _r):
            return _M_omero.grid.ProcessorCallback._op_isAccepted.end(self, _r)

        def responseRunning(self, jobIds, _ctx=None):
            return _M_omero.grid.ProcessorCallback._op_responseRunning.invoke(self, ((jobIds, ), _ctx))

        def begin_responseRunning(self, jobIds, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.ProcessorCallback._op_responseRunning.begin(self, ((jobIds, ), _response, _ex, _sent, _ctx))

        def end_responseRunning(self, _r):
            return _M_omero.grid.ProcessorCallback._op_responseRunning.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.grid.ProcessorCallbackPrx.ice_checkedCast(proxy, '::omero::grid::ProcessorCallback', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.grid.ProcessorCallbackPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero.grid._t_ProcessorCallbackPrx = IcePy.defineProxy('::omero::grid::ProcessorCallback', ProcessorCallbackPrx)

    _M_omero.grid._t_ProcessorCallback = IcePy.defineClass('::omero::grid::ProcessorCallback', ProcessorCallback, -1, (), True, False, None, (), ())
    ProcessorCallback._ice_type = _M_omero.grid._t_ProcessorCallback

    ProcessorCallback._op_isAccepted = IcePy.Operation('isAccepted', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_bool, False, 0), ((), IcePy._t_string, False, 0), ((), IcePy._t_string, False, 0)), (), None, ())
    ProcessorCallback._op_responseRunning = IcePy.Operation('responseRunning', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_omero.api._t_LongList, False, 0),), (), None, ())

    _M_omero.grid.ProcessorCallback = ProcessorCallback
    del ProcessorCallback

    _M_omero.grid.ProcessorCallbackPrx = ProcessorCallbackPrx
    del ProcessorCallbackPrx

if 'Processor' not in _M_omero.grid.__dict__:
    _M_omero.grid.Processor = Ice.createTempClass()
    class Processor(Ice.Object):
        '''Simple controller for Processes. Uses the session
id given to create an Ice.Config file which is used
as the sole argument to an execution of the given job.

Jobs are responsible for loading arguments from the
environment via the session id.'''
        def __init__(self):
            if Ice.getType(self) == _M_omero.grid.Processor:
                raise RuntimeError('omero.grid.Processor is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::grid::Processor')

        def ice_id(self, current=None):
            return '::omero::grid::Processor'

        def ice_staticId():
            return '::omero::grid::Processor'
        ice_staticId = staticmethod(ice_staticId)

        def willAccept(self, userContext, groupContext, scriptContext, cb, current=None):
            '''Called by [omero::grid::SharedResources] to find a suitable
target for [omero::grid::SharedResources::acquireProcessor].
New processor instances are added to the checklist by using
[omero::grid::SharedResources::addProcessor]. All processors
must respond with their session uuid in order to authorize
the action.'''
            pass

        def requestRunning(self, cb, current=None):
            '''Used by servers to find out what jobs are still active.
Response will be sent to [ProcessorCallback::responseRunning]'''
            pass

        def parseJob(self, session, jobObject, current=None):
            '''Parses a job and returns metadata definition required
for properly submitting the job. This object will be
cached by the server, and passed back into [processJob]'''
            pass

        def processJob(self, session, params, jobObject, current=None):
            '''Starts a process based on the given job
If this processor cannot handle the given job, a
null process will be returned. The [params] argument
was created by a previously call to [parseJob].'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_omero.grid._t_Processor)

        __repr__ = __str__

    _M_omero.grid.ProcessorPrx = Ice.createTempClass()
    class ProcessorPrx(Ice.ObjectPrx):

        '''Called by [omero::grid::SharedResources] to find a suitable
target for [omero::grid::SharedResources::acquireProcessor].
New processor instances are added to the checklist by using
[omero::grid::SharedResources::addProcessor]. All processors
must respond with their session uuid in order to authorize
the action.'''
        def willAccept(self, userContext, groupContext, scriptContext, cb, _ctx=None):
            return _M_omero.grid.Processor._op_willAccept.invoke(self, ((userContext, groupContext, scriptContext, cb), _ctx))

        '''Called by [omero::grid::SharedResources] to find a suitable
target for [omero::grid::SharedResources::acquireProcessor].
New processor instances are added to the checklist by using
[omero::grid::SharedResources::addProcessor]. All processors
must respond with their session uuid in order to authorize
the action.'''
        def begin_willAccept(self, userContext, groupContext, scriptContext, cb, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.Processor._op_willAccept.begin(self, ((userContext, groupContext, scriptContext, cb), _response, _ex, _sent, _ctx))

        '''Called by [omero::grid::SharedResources] to find a suitable
target for [omero::grid::SharedResources::acquireProcessor].
New processor instances are added to the checklist by using
[omero::grid::SharedResources::addProcessor]. All processors
must respond with their session uuid in order to authorize
the action.'''
        def end_willAccept(self, _r):
            return _M_omero.grid.Processor._op_willAccept.end(self, _r)

        '''Called by [omero::grid::SharedResources] to find a suitable
target for [omero::grid::SharedResources::acquireProcessor].
New processor instances are added to the checklist by using
[omero::grid::SharedResources::addProcessor]. All processors
must respond with their session uuid in order to authorize
the action.'''
        def willAccept_async(self, _cb, userContext, groupContext, scriptContext, cb, _ctx=None):
            return _M_omero.grid.Processor._op_willAccept.invokeAsync(self, (_cb, (userContext, groupContext, scriptContext, cb), _ctx))

        '''Used by servers to find out what jobs are still active.
Response will be sent to [ProcessorCallback::responseRunning]'''
        def requestRunning(self, cb, _ctx=None):
            return _M_omero.grid.Processor._op_requestRunning.invoke(self, ((cb, ), _ctx))

        '''Used by servers to find out what jobs are still active.
Response will be sent to [ProcessorCallback::responseRunning]'''
        def begin_requestRunning(self, cb, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.Processor._op_requestRunning.begin(self, ((cb, ), _response, _ex, _sent, _ctx))

        '''Used by servers to find out what jobs are still active.
Response will be sent to [ProcessorCallback::responseRunning]'''
        def end_requestRunning(self, _r):
            return _M_omero.grid.Processor._op_requestRunning.end(self, _r)

        '''Used by servers to find out what jobs are still active.
Response will be sent to [ProcessorCallback::responseRunning]'''
        def requestRunning_async(self, _cb, cb, _ctx=None):
            return _M_omero.grid.Processor._op_requestRunning.invokeAsync(self, (_cb, (cb, ), _ctx))

        '''Parses a job and returns metadata definition required
for properly submitting the job. This object will be
cached by the server, and passed back into [processJob]'''
        def parseJob(self, session, jobObject, _ctx=None):
            return _M_omero.grid.Processor._op_parseJob.invoke(self, ((session, jobObject), _ctx))

        '''Parses a job and returns metadata definition required
for properly submitting the job. This object will be
cached by the server, and passed back into [processJob]'''
        def begin_parseJob(self, session, jobObject, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.Processor._op_parseJob.begin(self, ((session, jobObject), _response, _ex, _sent, _ctx))

        '''Parses a job and returns metadata definition required
for properly submitting the job. This object will be
cached by the server, and passed back into [processJob]'''
        def end_parseJob(self, _r):
            return _M_omero.grid.Processor._op_parseJob.end(self, _r)

        '''Parses a job and returns metadata definition required
for properly submitting the job. This object will be
cached by the server, and passed back into [processJob]'''
        def parseJob_async(self, _cb, session, jobObject, _ctx=None):
            return _M_omero.grid.Processor._op_parseJob.invokeAsync(self, (_cb, (session, jobObject), _ctx))

        '''Starts a process based on the given job
If this processor cannot handle the given job, a
null process will be returned. The [params] argument
was created by a previously call to [parseJob].'''
        def processJob(self, session, params, jobObject, _ctx=None):
            return _M_omero.grid.Processor._op_processJob.invoke(self, ((session, params, jobObject), _ctx))

        '''Starts a process based on the given job
If this processor cannot handle the given job, a
null process will be returned. The [params] argument
was created by a previously call to [parseJob].'''
        def begin_processJob(self, session, params, jobObject, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.Processor._op_processJob.begin(self, ((session, params, jobObject), _response, _ex, _sent, _ctx))

        '''Starts a process based on the given job
If this processor cannot handle the given job, a
null process will be returned. The [params] argument
was created by a previously call to [parseJob].'''
        def end_processJob(self, _r):
            return _M_omero.grid.Processor._op_processJob.end(self, _r)

        '''Starts a process based on the given job
If this processor cannot handle the given job, a
null process will be returned. The [params] argument
was created by a previously call to [parseJob].'''
        def processJob_async(self, _cb, session, params, jobObject, _ctx=None):
            return _M_omero.grid.Processor._op_processJob.invokeAsync(self, (_cb, (session, params, jobObject), _ctx))

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.grid.ProcessorPrx.ice_checkedCast(proxy, '::omero::grid::Processor', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.grid.ProcessorPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero.grid._t_ProcessorPrx = IcePy.defineProxy('::omero::grid::Processor', ProcessorPrx)

    _M_omero.grid._t_Processor = IcePy.defineClass('::omero::grid::Processor', Processor, -1, (), True, False, None, (), ())
    Processor._ice_type = _M_omero.grid._t_Processor

    Processor._op_willAccept = IcePy.Operation('willAccept', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_omero.model._t_Experimenter, False, 0), ((), _M_omero.model._t_ExperimenterGroup, False, 0), ((), _M_omero.model._t_Job, False, 0), ((), _M_omero.grid._t_ProcessorCallbackPrx, False, 0)), (), None, ())
    Processor._op_requestRunning = IcePy.Operation('requestRunning', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_omero.grid._t_ProcessorCallbackPrx, False, 0),), (), None, ())
    Processor._op_parseJob = IcePy.Operation('parseJob', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0), ((), _M_omero.model._t_Job, False, 0)), (), ((), _M_omero.grid._t_JobParams, False, 0), (_M_omero._t_ServerError,))
    Processor._op_processJob = IcePy.Operation('processJob', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_string, False, 0), ((), _M_omero.grid._t_JobParams, False, 0), ((), _M_omero.model._t_Job, False, 0)), (), ((), _M_omero.grid._t_ProcessPrx, False, 0), (_M_omero._t_ServerError,))

    _M_omero.grid.Processor = Processor
    del Processor

    _M_omero.grid.ProcessorPrx = ProcessorPrx
    del ProcessorPrx

if 'InteractiveProcessor' not in _M_omero.grid.__dict__:
    _M_omero.grid.InteractiveProcessor = Ice.createTempClass()
    class InteractiveProcessor(Ice.Object):
        '''Client facing interface to the background processing
framework. If a user needs interactivity, one of these
processors should be acquired from the ServiceFactory.
Otherwise, a Job can be submitted via JobHandle.'''
        def __init__(self):
            if Ice.getType(self) == _M_omero.grid.InteractiveProcessor:
                raise RuntimeError('omero.grid.InteractiveProcessor is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::grid::InteractiveProcessor')

        def ice_id(self, current=None):
            return '::omero::grid::InteractiveProcessor'

        def ice_staticId():
            return '::omero::grid::InteractiveProcessor'
        ice_staticId = staticmethod(ice_staticId)

        def expires(self, current=None):
            '''Returns the system clock time in milliseconds since the epoch
at which this processor will be reaped.'''
            pass

        def getJob(self, current=None):
            '''Returns the job which defines this processor. This may be
only the last job associated with the processor if execute
is called multiple times.'''
            pass

        def params(self, current=None):
            '''Retrieves the parameters needed to be passed in an execution
and the results which will be passed back out.

This method is guaranteed to return a non-null value or throw an exception.'''
            pass

        def execute(self, inputs, current=None):
            '''Executes an instance of the job returned by getJob() using
the given map as inputs.'''
            pass

        def getResults(self, proc, current=None):
            '''Retrieve the results for the given process. This will throw
an ApiUsageException if called before the process has returned.
Use either process.poll() or process.wait() or a ProcessCallback
to wait for completion before calling.

If the user has not overridden or disabled the output values
"stdout" and "stderr", these will be filled with the OriginalFile
instances uploaded after completion under the key values of the
same name.'''
            pass

        def setDetach(self, detach, current=None):
            '''Sets whether or not cancel will be called on the current
[Process] on stop. If detach is true, then the [Process]
will continue running. Otherwise, Process.cancel() willl
be called, before prepairing for another run.

false by default'''
            pass

        def stop(self, current=None):
            '''Clears the current execution of [omero::model::Job] from
the processor to prepare for another execution.

cancel() will be called on the current [Process]
if detach is set to false.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_omero.grid._t_InteractiveProcessor)

        __repr__ = __str__

    _M_omero.grid.InteractiveProcessorPrx = Ice.createTempClass()
    class InteractiveProcessorPrx(Ice.ObjectPrx):

        '''Returns the system clock time in milliseconds since the epoch
at which this processor will be reaped.'''
        def expires(self, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_expires.invoke(self, ((), _ctx))

        '''Returns the system clock time in milliseconds since the epoch
at which this processor will be reaped.'''
        def begin_expires(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_expires.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Returns the system clock time in milliseconds since the epoch
at which this processor will be reaped.'''
        def end_expires(self, _r):
            return _M_omero.grid.InteractiveProcessor._op_expires.end(self, _r)

        '''Returns the system clock time in milliseconds since the epoch
at which this processor will be reaped.'''
        def expires_async(self, _cb, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_expires.invokeAsync(self, (_cb, (), _ctx))

        '''Returns the job which defines this processor. This may be
only the last job associated with the processor if execute
is called multiple times.'''
        def getJob(self, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_getJob.invoke(self, ((), _ctx))

        '''Returns the job which defines this processor. This may be
only the last job associated with the processor if execute
is called multiple times.'''
        def begin_getJob(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_getJob.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Returns the job which defines this processor. This may be
only the last job associated with the processor if execute
is called multiple times.'''
        def end_getJob(self, _r):
            return _M_omero.grid.InteractiveProcessor._op_getJob.end(self, _r)

        '''Returns the job which defines this processor. This may be
only the last job associated with the processor if execute
is called multiple times.'''
        def getJob_async(self, _cb, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_getJob.invokeAsync(self, (_cb, (), _ctx))

        '''Retrieves the parameters needed to be passed in an execution
and the results which will be passed back out.

This method is guaranteed to return a non-null value or throw an exception.'''
        def params(self, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_params.invoke(self, ((), _ctx))

        '''Retrieves the parameters needed to be passed in an execution
and the results which will be passed back out.

This method is guaranteed to return a non-null value or throw an exception.'''
        def begin_params(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_params.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Retrieves the parameters needed to be passed in an execution
and the results which will be passed back out.

This method is guaranteed to return a non-null value or throw an exception.'''
        def end_params(self, _r):
            return _M_omero.grid.InteractiveProcessor._op_params.end(self, _r)

        '''Retrieves the parameters needed to be passed in an execution
and the results which will be passed back out.

This method is guaranteed to return a non-null value or throw an exception.'''
        def params_async(self, _cb, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_params.invokeAsync(self, (_cb, (), _ctx))

        '''Executes an instance of the job returned by getJob() using
the given map as inputs.'''
        def execute(self, inputs, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_execute.invoke(self, ((inputs, ), _ctx))

        '''Executes an instance of the job returned by getJob() using
the given map as inputs.'''
        def begin_execute(self, inputs, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_execute.begin(self, ((inputs, ), _response, _ex, _sent, _ctx))

        '''Executes an instance of the job returned by getJob() using
the given map as inputs.'''
        def end_execute(self, _r):
            return _M_omero.grid.InteractiveProcessor._op_execute.end(self, _r)

        '''Executes an instance of the job returned by getJob() using
the given map as inputs.'''
        def execute_async(self, _cb, inputs, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_execute.invokeAsync(self, (_cb, (inputs, ), _ctx))

        '''Retrieve the results for the given process. This will throw
an ApiUsageException if called before the process has returned.
Use either process.poll() or process.wait() or a ProcessCallback
to wait for completion before calling.

If the user has not overridden or disabled the output values
"stdout" and "stderr", these will be filled with the OriginalFile
instances uploaded after completion under the key values of the
same name.'''
        def getResults(self, proc, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_getResults.invoke(self, ((proc, ), _ctx))

        '''Retrieve the results for the given process. This will throw
an ApiUsageException if called before the process has returned.
Use either process.poll() or process.wait() or a ProcessCallback
to wait for completion before calling.

If the user has not overridden or disabled the output values
"stdout" and "stderr", these will be filled with the OriginalFile
instances uploaded after completion under the key values of the
same name.'''
        def begin_getResults(self, proc, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_getResults.begin(self, ((proc, ), _response, _ex, _sent, _ctx))

        '''Retrieve the results for the given process. This will throw
an ApiUsageException if called before the process has returned.
Use either process.poll() or process.wait() or a ProcessCallback
to wait for completion before calling.

If the user has not overridden or disabled the output values
"stdout" and "stderr", these will be filled with the OriginalFile
instances uploaded after completion under the key values of the
same name.'''
        def end_getResults(self, _r):
            return _M_omero.grid.InteractiveProcessor._op_getResults.end(self, _r)

        '''Retrieve the results for the given process. This will throw
an ApiUsageException if called before the process has returned.
Use either process.poll() or process.wait() or a ProcessCallback
to wait for completion before calling.

If the user has not overridden or disabled the output values
"stdout" and "stderr", these will be filled with the OriginalFile
instances uploaded after completion under the key values of the
same name.'''
        def getResults_async(self, _cb, proc, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_getResults.invokeAsync(self, (_cb, (proc, ), _ctx))

        '''Sets whether or not cancel will be called on the current
[Process] on stop. If detach is true, then the [Process]
will continue running. Otherwise, Process.cancel() willl
be called, before prepairing for another run.

false by default'''
        def setDetach(self, detach, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_setDetach.invoke(self, ((detach, ), _ctx))

        '''Sets whether or not cancel will be called on the current
[Process] on stop. If detach is true, then the [Process]
will continue running. Otherwise, Process.cancel() willl
be called, before prepairing for another run.

false by default'''
        def begin_setDetach(self, detach, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_setDetach.begin(self, ((detach, ), _response, _ex, _sent, _ctx))

        '''Sets whether or not cancel will be called on the current
[Process] on stop. If detach is true, then the [Process]
will continue running. Otherwise, Process.cancel() willl
be called, before prepairing for another run.

false by default'''
        def end_setDetach(self, _r):
            return _M_omero.grid.InteractiveProcessor._op_setDetach.end(self, _r)

        '''Sets whether or not cancel will be called on the current
[Process] on stop. If detach is true, then the [Process]
will continue running. Otherwise, Process.cancel() willl
be called, before prepairing for another run.

false by default'''
        def setDetach_async(self, _cb, detach, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_setDetach.invokeAsync(self, (_cb, (detach, ), _ctx))

        '''Clears the current execution of [omero::model::Job] from
the processor to prepare for another execution.

cancel() will be called on the current [Process]
if detach is set to false.'''
        def stop(self, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_stop.invoke(self, ((), _ctx))

        '''Clears the current execution of [omero::model::Job] from
the processor to prepare for another execution.

cancel() will be called on the current [Process]
if detach is set to false.'''
        def begin_stop(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_stop.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Clears the current execution of [omero::model::Job] from
the processor to prepare for another execution.

cancel() will be called on the current [Process]
if detach is set to false.'''
        def end_stop(self, _r):
            return _M_omero.grid.InteractiveProcessor._op_stop.end(self, _r)

        '''Clears the current execution of [omero::model::Job] from
the processor to prepare for another execution.

cancel() will be called on the current [Process]
if detach is set to false.'''
        def stop_async(self, _cb, _ctx=None):
            return _M_omero.grid.InteractiveProcessor._op_stop.invokeAsync(self, (_cb, (), _ctx))

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.grid.InteractiveProcessorPrx.ice_checkedCast(proxy, '::omero::grid::InteractiveProcessor', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.grid.InteractiveProcessorPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero.grid._t_InteractiveProcessorPrx = IcePy.defineProxy('::omero::grid::InteractiveProcessor', InteractiveProcessorPrx)

    _M_omero.grid._t_InteractiveProcessor = IcePy.defineClass('::omero::grid::InteractiveProcessor', InteractiveProcessor, -1, (), True, False, None, (), ())
    InteractiveProcessor._ice_type = _M_omero.grid._t_InteractiveProcessor

    InteractiveProcessor._op_expires = IcePy.Operation('expires', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_long, False, 0), ())
    InteractiveProcessor._op_getJob = IcePy.Operation('getJob', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_omero.model._t_Job, False, 0), ())
    InteractiveProcessor._op_params = IcePy.Operation('params', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_omero.grid._t_JobParams, False, 0), (_M_omero._t_ServerError,))
    InteractiveProcessor._op_execute = IcePy.Operation('execute', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_omero._t_RMap, False, 0),), (), ((), _M_omero.grid._t_ProcessPrx, False, 0), (_M_omero._t_ServerError,))
    InteractiveProcessor._op_getResults = IcePy.Operation('getResults', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), _M_omero.grid._t_ProcessPrx, False, 0),), (), ((), _M_omero._t_RMap, False, 0), (_M_omero._t_ServerError,))
    InteractiveProcessor._op_setDetach = IcePy.Operation('setDetach', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (((), IcePy._t_bool, False, 0),), (), ((), IcePy._t_bool, False, 0), (_M_omero._t_ServerError,))
    InteractiveProcessor._op_stop = IcePy.Operation('stop', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_omero._t_ServerError,))

    _M_omero.grid.InteractiveProcessor = InteractiveProcessor
    del InteractiveProcessor

    _M_omero.grid.InteractiveProcessorPrx = InteractiveProcessorPrx
    del InteractiveProcessorPrx

if '_t_InteractiveProcessorList' not in _M_omero.grid.__dict__:
    _M_omero.grid._t_InteractiveProcessorList = IcePy.defineSequence('::omero::grid::InteractiveProcessorList', (), _M_omero.grid._t_InteractiveProcessorPrx)

# End of module omero.grid

__name__ = 'omero'

# End of module omero
