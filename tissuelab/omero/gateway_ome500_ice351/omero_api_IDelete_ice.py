# **********************************************************************
#
# Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
#
# This copy of Ice is licensed to you under the terms described in the
# ICE_LICENSE file included in this distribution.
#
# **********************************************************************
#
# Ice version 3.5.1
#
# <auto-generated>
#
# Generated from file `IDelete.ice'
#
# Warning: do not edit this file.
#
# </auto-generated>
#

import Ice, IcePy
import omero_ModelF_ice
import omero_ServicesF_ice
import omero_Collections_ice

# Included module omero
_M_omero = Ice.openModule('omero')

# Included module omero.model
_M_omero.model = Ice.openModule('omero.model')

# Included module Ice
_M_Ice = Ice.openModule('Ice')

# Included module Glacier2
_M_Glacier2 = Ice.openModule('Glacier2')

# Included module omero.sys
_M_omero.sys = Ice.openModule('omero.sys')

# Included module omero.api
_M_omero.api = Ice.openModule('omero.api')

# Included module omero.grid
_M_omero.grid = Ice.openModule('omero.grid')

# Start of module omero
__name__ = 'omero'

# Start of module omero.api
__name__ = 'omero.api'

# Start of module omero.api.delete
_M_omero.api.delete = Ice.openModule('omero.api.delete')
__name__ = 'omero.api.delete'
_M_omero.api.delete.__doc__ = '''Exploratory Delete API for background processing of deletes.

For more information, see ticket #2665.'''

_M_omero.api.delete.ORPHAN = "ORPHAN"

_M_omero.api.delete.REAP = "REAP"

_M_omero.api.delete.SOFT = "SOFT"

_M_omero.api.delete.HARD = "HARD"

if 'DeleteCommand' not in _M_omero.api.delete.__dict__:
    _M_omero.api.delete.DeleteCommand = Ice.createTempClass()
    class DeleteCommand(object):
        '''Command object which represents a single delete request. Several of these
can be passed to the [IDelete::queueDelete] method at once. All will occur
in the same transation.'''
        def __init__(self, type='', id=0, options=None):
            self.type = type
            self.id = id
            self.options = options

        def __eq__(self, other):
            if other is None:
                return False
            elif not isinstance(other, _M_omero.api.delete.DeleteCommand):
                return NotImplemented
            else:
                if self.type != other.type:
                    return False
                if self.id != other.id:
                    return False
                if self.options != other.options:
                    return False
                return True

        def __ne__(self, other):
            return not self.__eq__(other)

        def __str__(self):
            return IcePy.stringify(self, _M_omero.api.delete._t_DeleteCommand)

        __repr__ = __str__

    _M_omero.api.delete._t_DeleteCommand = IcePy.defineStruct('::omero::api::delete::DeleteCommand', DeleteCommand, (), (
        ('type', (), IcePy._t_string),
        ('id', (), IcePy._t_long),
        ('options', (), _M_omero.api._t_StringStringMap)
    ))

    _M_omero.api.delete.DeleteCommand = DeleteCommand
    del DeleteCommand

if '_t_DeleteCommands' not in _M_omero.api.delete.__dict__:
    _M_omero.api.delete._t_DeleteCommands = IcePy.defineSequence('::omero::api::delete::DeleteCommands', (), _M_omero.api.delete._t_DeleteCommand)

if 'DeleteReport' not in _M_omero.api.delete.__dict__:
    _M_omero.api.delete.DeleteReport = Ice.createTempClass()
    class DeleteReport(Ice.Object):
        '''Status object which is returned for each [DeleteCommand] passed to
[IDelete::queueCommand].'''
        def __init__(self, command=Ice._struct_marker, error='', warning='', undeletedFiles=None, steps=0, scheduledDeletes=0, actualDeletes=0, start=0, stepStarts=None, stepStops=None, stop=0):
            if command is Ice._struct_marker:
                self.command = _M_omero.api.delete.DeleteCommand()
            else:
                self.command = command
            self.error = error
            self.warning = warning
            self.undeletedFiles = undeletedFiles
            self.steps = steps
            self.scheduledDeletes = scheduledDeletes
            self.actualDeletes = actualDeletes
            self.start = start
            self.stepStarts = stepStarts
            self.stepStops = stepStops
            self.stop = stop

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::api::delete::DeleteReport')

        def ice_id(self, current=None):
            return '::omero::api::delete::DeleteReport'

        def ice_staticId():
            return '::omero::api::delete::DeleteReport'
        ice_staticId = staticmethod(ice_staticId)

        def __str__(self):
            return IcePy.stringify(self, _M_omero.api.delete._t_DeleteReport)

        __repr__ = __str__

    _M_omero.api.delete.DeleteReportPrx = Ice.createTempClass()
    class DeleteReportPrx(Ice.ObjectPrx):

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.api.delete.DeleteReportPrx.ice_checkedCast(proxy, '::omero::api::delete::DeleteReport', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.api.delete.DeleteReportPrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero.api.delete._t_DeleteReportPrx = IcePy.defineProxy('::omero::api::delete::DeleteReport', DeleteReportPrx)

    _M_omero.api.delete._t_DeleteReport = IcePy.defineClass('::omero::api::delete::DeleteReport', DeleteReport, -1, (), False, False, None, (), (
        ('command', (), _M_omero.api.delete._t_DeleteCommand, False, 0),
        ('error', (), IcePy._t_string, False, 0),
        ('warning', (), IcePy._t_string, False, 0),
        ('undeletedFiles', (), _M_omero.api._t_IdListMap, False, 0),
        ('steps', (), IcePy._t_int, False, 0),
        ('scheduledDeletes', (), IcePy._t_long, False, 0),
        ('actualDeletes', (), IcePy._t_long, False, 0),
        ('start', (), IcePy._t_long, False, 0),
        ('stepStarts', (), _M_omero.api._t_LongArray, False, 0),
        ('stepStops', (), _M_omero.api._t_LongArray, False, 0),
        ('stop', (), IcePy._t_long, False, 0)
    ))
    DeleteReport._ice_type = _M_omero.api.delete._t_DeleteReport

    _M_omero.api.delete.DeleteReport = DeleteReport
    del DeleteReport

    _M_omero.api.delete.DeleteReportPrx = DeleteReportPrx
    del DeleteReportPrx

if '_t_DeleteReports' not in _M_omero.api.delete.__dict__:
    _M_omero.api.delete._t_DeleteReports = IcePy.defineSequence('::omero::api::delete::DeleteReports', (), _M_omero.api.delete._t_DeleteReport)

if 'DeleteHandle' not in _M_omero.api.delete.__dict__:
    _M_omero.api.delete.DeleteHandle = Ice.createTempClass()
    class DeleteHandle(Ice.Object):
        '''Returned by [IDelete] to allow managing of queued delete operations.'''
        def __init__(self):
            if Ice.getType(self) == _M_omero.api.delete.DeleteHandle:
                raise RuntimeError('omero.api.delete.DeleteHandle is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::api::delete::DeleteHandle')

        def ice_id(self, current=None):
            return '::omero::api::delete::DeleteHandle'

        def ice_staticId():
            return '::omero::api::delete::DeleteHandle'
        ice_staticId = staticmethod(ice_staticId)

        def commands(self, current=None):
            '''Returns the [DeleteCommand] instances which were used to create
this handle.'''
            pass

        def report(self, current=None):
            '''Returns a report of what happened. Any errors will produce output as well
as any warnings, such as "Tag was orphaned" when using the "SOFT" option.
An error can be detected by a non-empty string for the [DeleteReport::error]
field.'''
            pass

        def finished(self, current=None):
            '''Returns whether processing of all commands has completed, whether successfully
or not.'''
            pass

        def errors(self, current=None):
            '''Returns the number of errors that were encountered. If greater than
zero, then the transaction was rolled back.'''
            pass

        def cancel(self, current=None):
            '''Prevents further [DeleteCommand]s from being processed and rolls back any
changes already made by the transaction. If all commands were already
processed, this method returns false to signal that the rollback was not
possible.'''
            pass

        def close(self, current=None):
            '''Removes the proxy from the server's adapter. Any calls on this
proxy after close will receive an [Ice::ObjectNotExistException].'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_omero.api.delete._t_DeleteHandle)

        __repr__ = __str__

    _M_omero.api.delete.DeleteHandlePrx = Ice.createTempClass()
    class DeleteHandlePrx(Ice.ObjectPrx):

        '''Returns the [DeleteCommand] instances which were used to create
this handle.'''
        def commands(self, _ctx=None):
            return _M_omero.api.delete.DeleteHandle._op_commands.invoke(self, ((), _ctx))

        '''Returns the [DeleteCommand] instances which were used to create
this handle.'''
        def begin_commands(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.api.delete.DeleteHandle._op_commands.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Returns the [DeleteCommand] instances which were used to create
this handle.'''
        def end_commands(self, _r):
            return _M_omero.api.delete.DeleteHandle._op_commands.end(self, _r)

        '''Returns a report of what happened. Any errors will produce output as well
as any warnings, such as "Tag was orphaned" when using the "SOFT" option.
An error can be detected by a non-empty string for the [DeleteReport::error]
field.'''
        def report(self, _ctx=None):
            return _M_omero.api.delete.DeleteHandle._op_report.invoke(self, ((), _ctx))

        '''Returns a report of what happened. Any errors will produce output as well
as any warnings, such as "Tag was orphaned" when using the "SOFT" option.
An error can be detected by a non-empty string for the [DeleteReport::error]
field.'''
        def begin_report(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.api.delete.DeleteHandle._op_report.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Returns a report of what happened. Any errors will produce output as well
as any warnings, such as "Tag was orphaned" when using the "SOFT" option.
An error can be detected by a non-empty string for the [DeleteReport::error]
field.'''
        def end_report(self, _r):
            return _M_omero.api.delete.DeleteHandle._op_report.end(self, _r)

        '''Returns whether processing of all commands has completed, whether successfully
or not.'''
        def finished(self, _ctx=None):
            return _M_omero.api.delete.DeleteHandle._op_finished.invoke(self, ((), _ctx))

        '''Returns whether processing of all commands has completed, whether successfully
or not.'''
        def begin_finished(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.api.delete.DeleteHandle._op_finished.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Returns whether processing of all commands has completed, whether successfully
or not.'''
        def end_finished(self, _r):
            return _M_omero.api.delete.DeleteHandle._op_finished.end(self, _r)

        '''Returns the number of errors that were encountered. If greater than
zero, then the transaction was rolled back.'''
        def errors(self, _ctx=None):
            return _M_omero.api.delete.DeleteHandle._op_errors.invoke(self, ((), _ctx))

        '''Returns the number of errors that were encountered. If greater than
zero, then the transaction was rolled back.'''
        def begin_errors(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.api.delete.DeleteHandle._op_errors.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Returns the number of errors that were encountered. If greater than
zero, then the transaction was rolled back.'''
        def end_errors(self, _r):
            return _M_omero.api.delete.DeleteHandle._op_errors.end(self, _r)

        '''Prevents further [DeleteCommand]s from being processed and rolls back any
changes already made by the transaction. If all commands were already
processed, this method returns false to signal that the rollback was not
possible.'''
        def cancel(self, _ctx=None):
            return _M_omero.api.delete.DeleteHandle._op_cancel.invoke(self, ((), _ctx))

        '''Prevents further [DeleteCommand]s from being processed and rolls back any
changes already made by the transaction. If all commands were already
processed, this method returns false to signal that the rollback was not
possible.'''
        def begin_cancel(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.api.delete.DeleteHandle._op_cancel.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Prevents further [DeleteCommand]s from being processed and rolls back any
changes already made by the transaction. If all commands were already
processed, this method returns false to signal that the rollback was not
possible.'''
        def end_cancel(self, _r):
            return _M_omero.api.delete.DeleteHandle._op_cancel.end(self, _r)

        '''Removes the proxy from the server's adapter. Any calls on this
proxy after close will receive an [Ice::ObjectNotExistException].'''
        def close(self, _ctx=None):
            return _M_omero.api.delete.DeleteHandle._op_close.invoke(self, ((), _ctx))

        '''Removes the proxy from the server's adapter. Any calls on this
proxy after close will receive an [Ice::ObjectNotExistException].'''
        def begin_close(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.api.delete.DeleteHandle._op_close.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Removes the proxy from the server's adapter. Any calls on this
proxy after close will receive an [Ice::ObjectNotExistException].'''
        def end_close(self, _r):
            return _M_omero.api.delete.DeleteHandle._op_close.end(self, _r)

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.api.delete.DeleteHandlePrx.ice_checkedCast(proxy, '::omero::api::delete::DeleteHandle', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.api.delete.DeleteHandlePrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero.api.delete._t_DeleteHandlePrx = IcePy.defineProxy('::omero::api::delete::DeleteHandle', DeleteHandlePrx)

    _M_omero.api.delete._t_DeleteHandle = IcePy.defineClass('::omero::api::delete::DeleteHandle', DeleteHandle, -1, (), True, False, None, (), ())
    DeleteHandle._ice_type = _M_omero.api.delete._t_DeleteHandle

    DeleteHandle._op_commands = IcePy.Operation('commands', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_omero.api.delete._t_DeleteCommands, False, 0), (_M_omero._t_ServerError,))
    DeleteHandle._op_commands.deprecate(" use omero::cmd::Handle instead")
    DeleteHandle._op_report = IcePy.Operation('report', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), _M_omero.api.delete._t_DeleteReports, False, 0), (_M_omero._t_ServerError,))
    DeleteHandle._op_report.deprecate(" use omero::cmd::Handle instead")
    DeleteHandle._op_finished = IcePy.Operation('finished', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_bool, False, 0), (_M_omero._t_ServerError,))
    DeleteHandle._op_finished.deprecate(" use omero::cmd::Handle instead")
    DeleteHandle._op_errors = IcePy.Operation('errors', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_int, False, 0), (_M_omero._t_ServerError,))
    DeleteHandle._op_errors.deprecate(" use omero::cmd::Handle instead")
    DeleteHandle._op_cancel = IcePy.Operation('cancel', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), ((), IcePy._t_bool, False, 0), (_M_omero._t_ServerError,))
    DeleteHandle._op_cancel.deprecate(" use omero::cmd::Handle instead")
    DeleteHandle._op_close = IcePy.Operation('close', Ice.OperationMode.Normal, Ice.OperationMode.Normal, False, None, (), (), (), None, (_M_omero._t_ServerError,))
    DeleteHandle._op_close.deprecate(" use omero::cmd::Handle instead")

    _M_omero.api.delete.DeleteHandle = DeleteHandle
    del DeleteHandle

    _M_omero.api.delete.DeleteHandlePrx = DeleteHandlePrx
    del DeleteHandlePrx

# End of module omero.api.delete

__name__ = 'omero.api'

if 'IDelete' not in _M_omero.api.__dict__:
    _M_omero.api.IDelete = Ice.createTempClass()
    class IDelete(_M_omero.api.ServiceInterface):
        '''See IDelete.html'''
        def __init__(self):
            if Ice.getType(self) == _M_omero.api.IDelete:
                raise RuntimeError('omero.api.IDelete is an abstract class')

        def ice_ids(self, current=None):
            return ('::Ice::Object', '::omero::api::IDelete', '::omero::api::ServiceInterface')

        def ice_id(self, current=None):
            return '::omero::api::IDelete'

        def ice_staticId():
            return '::omero::api::IDelete'
        ice_staticId = staticmethod(ice_staticId)

        def checkImageDelete_async(self, _cb, id, force, current=None):
            pass

        def previewImageDelete_async(self, _cb, id, force, current=None):
            pass

        def deleteImage_async(self, _cb, id, force, current=None):
            pass

        def deleteImages_async(self, _cb, ids, force, current=None):
            pass

        def deleteImagesByDataset_async(self, _cb, datasetId, force, current=None):
            pass

        def deleteSettings_async(self, _cb, imageId, current=None):
            pass

        def deletePlate_async(self, _cb, plateId, current=None):
            pass

        def availableCommands_async(self, _cb, current=None):
            '''Returns a list of [DeleteCommand] instances with type and options filled,
but whose id value can be ignored.'''
            pass

        def queueDelete_async(self, _cb, commands, current=None):
            '''Queue multiple deletes for later execution. The [DeleteHandle] instance can
be queried for the state of the delete.'''
            pass

        def __str__(self):
            return IcePy.stringify(self, _M_omero.api._t_IDelete)

        __repr__ = __str__

    _M_omero.api.IDeletePrx = Ice.createTempClass()
    class IDeletePrx(_M_omero.api.ServiceInterfacePrx):

        def checkImageDelete(self, id, force, _ctx=None):
            return _M_omero.api.IDelete._op_checkImageDelete.invoke(self, ((id, force), _ctx))

        def begin_checkImageDelete(self, id, force, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.api.IDelete._op_checkImageDelete.begin(self, ((id, force), _response, _ex, _sent, _ctx))

        def end_checkImageDelete(self, _r):
            return _M_omero.api.IDelete._op_checkImageDelete.end(self, _r)

        def checkImageDelete_async(self, _cb, id, force, _ctx=None):
            return _M_omero.api.IDelete._op_checkImageDelete.invokeAsync(self, (_cb, (id, force), _ctx))

        def previewImageDelete(self, id, force, _ctx=None):
            return _M_omero.api.IDelete._op_previewImageDelete.invoke(self, ((id, force), _ctx))

        def begin_previewImageDelete(self, id, force, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.api.IDelete._op_previewImageDelete.begin(self, ((id, force), _response, _ex, _sent, _ctx))

        def end_previewImageDelete(self, _r):
            return _M_omero.api.IDelete._op_previewImageDelete.end(self, _r)

        def previewImageDelete_async(self, _cb, id, force, _ctx=None):
            return _M_omero.api.IDelete._op_previewImageDelete.invokeAsync(self, (_cb, (id, force), _ctx))

        def deleteImage(self, id, force, _ctx=None):
            return _M_omero.api.IDelete._op_deleteImage.invoke(self, ((id, force), _ctx))

        def begin_deleteImage(self, id, force, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.api.IDelete._op_deleteImage.begin(self, ((id, force), _response, _ex, _sent, _ctx))

        def end_deleteImage(self, _r):
            return _M_omero.api.IDelete._op_deleteImage.end(self, _r)

        def deleteImage_async(self, _cb, id, force, _ctx=None):
            return _M_omero.api.IDelete._op_deleteImage.invokeAsync(self, (_cb, (id, force), _ctx))

        def deleteImages(self, ids, force, _ctx=None):
            return _M_omero.api.IDelete._op_deleteImages.invoke(self, ((ids, force), _ctx))

        def begin_deleteImages(self, ids, force, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.api.IDelete._op_deleteImages.begin(self, ((ids, force), _response, _ex, _sent, _ctx))

        def end_deleteImages(self, _r):
            return _M_omero.api.IDelete._op_deleteImages.end(self, _r)

        def deleteImages_async(self, _cb, ids, force, _ctx=None):
            return _M_omero.api.IDelete._op_deleteImages.invokeAsync(self, (_cb, (ids, force), _ctx))

        def deleteImagesByDataset(self, datasetId, force, _ctx=None):
            return _M_omero.api.IDelete._op_deleteImagesByDataset.invoke(self, ((datasetId, force), _ctx))

        def begin_deleteImagesByDataset(self, datasetId, force, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.api.IDelete._op_deleteImagesByDataset.begin(self, ((datasetId, force), _response, _ex, _sent, _ctx))

        def end_deleteImagesByDataset(self, _r):
            return _M_omero.api.IDelete._op_deleteImagesByDataset.end(self, _r)

        def deleteImagesByDataset_async(self, _cb, datasetId, force, _ctx=None):
            return _M_omero.api.IDelete._op_deleteImagesByDataset.invokeAsync(self, (_cb, (datasetId, force), _ctx))

        def deleteSettings(self, imageId, _ctx=None):
            return _M_omero.api.IDelete._op_deleteSettings.invoke(self, ((imageId, ), _ctx))

        def begin_deleteSettings(self, imageId, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.api.IDelete._op_deleteSettings.begin(self, ((imageId, ), _response, _ex, _sent, _ctx))

        def end_deleteSettings(self, _r):
            return _M_omero.api.IDelete._op_deleteSettings.end(self, _r)

        def deleteSettings_async(self, _cb, imageId, _ctx=None):
            return _M_omero.api.IDelete._op_deleteSettings.invokeAsync(self, (_cb, (imageId, ), _ctx))

        def deletePlate(self, plateId, _ctx=None):
            return _M_omero.api.IDelete._op_deletePlate.invoke(self, ((plateId, ), _ctx))

        def begin_deletePlate(self, plateId, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.api.IDelete._op_deletePlate.begin(self, ((plateId, ), _response, _ex, _sent, _ctx))

        def end_deletePlate(self, _r):
            return _M_omero.api.IDelete._op_deletePlate.end(self, _r)

        def deletePlate_async(self, _cb, plateId, _ctx=None):
            return _M_omero.api.IDelete._op_deletePlate.invokeAsync(self, (_cb, (plateId, ), _ctx))

        '''Returns a list of [DeleteCommand] instances with type and options filled,
but whose id value can be ignored.'''
        def availableCommands(self, _ctx=None):
            return _M_omero.api.IDelete._op_availableCommands.invoke(self, ((), _ctx))

        '''Returns a list of [DeleteCommand] instances with type and options filled,
but whose id value can be ignored.'''
        def begin_availableCommands(self, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.api.IDelete._op_availableCommands.begin(self, ((), _response, _ex, _sent, _ctx))

        '''Returns a list of [DeleteCommand] instances with type and options filled,
but whose id value can be ignored.'''
        def end_availableCommands(self, _r):
            return _M_omero.api.IDelete._op_availableCommands.end(self, _r)

        '''Returns a list of [DeleteCommand] instances with type and options filled,
but whose id value can be ignored.'''
        def availableCommands_async(self, _cb, _ctx=None):
            return _M_omero.api.IDelete._op_availableCommands.invokeAsync(self, (_cb, (), _ctx))

        '''Queue multiple deletes for later execution. The [DeleteHandle] instance can
be queried for the state of the delete.'''
        def queueDelete(self, commands, _ctx=None):
            return _M_omero.api.IDelete._op_queueDelete.invoke(self, ((commands, ), _ctx))

        '''Queue multiple deletes for later execution. The [DeleteHandle] instance can
be queried for the state of the delete.'''
        def begin_queueDelete(self, commands, _response=None, _ex=None, _sent=None, _ctx=None):
            return _M_omero.api.IDelete._op_queueDelete.begin(self, ((commands, ), _response, _ex, _sent, _ctx))

        '''Queue multiple deletes for later execution. The [DeleteHandle] instance can
be queried for the state of the delete.'''
        def end_queueDelete(self, _r):
            return _M_omero.api.IDelete._op_queueDelete.end(self, _r)

        '''Queue multiple deletes for later execution. The [DeleteHandle] instance can
be queried for the state of the delete.'''
        def queueDelete_async(self, _cb, commands, _ctx=None):
            return _M_omero.api.IDelete._op_queueDelete.invokeAsync(self, (_cb, (commands, ), _ctx))

        def checkedCast(proxy, facetOrCtx=None, _ctx=None):
            return _M_omero.api.IDeletePrx.ice_checkedCast(proxy, '::omero::api::IDelete', facetOrCtx, _ctx)
        checkedCast = staticmethod(checkedCast)

        def uncheckedCast(proxy, facet=None):
            return _M_omero.api.IDeletePrx.ice_uncheckedCast(proxy, facet)
        uncheckedCast = staticmethod(uncheckedCast)

    _M_omero.api._t_IDeletePrx = IcePy.defineProxy('::omero::api::IDelete', IDeletePrx)

    _M_omero.api._t_IDelete = IcePy.defineClass('::omero::api::IDelete', IDelete, -1, (), True, False, None, (_M_omero.api._t_ServiceInterface,), ())
    IDelete._ice_type = _M_omero.api._t_IDelete

    IDelete._op_checkImageDelete = IcePy.Operation('checkImageDelete', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_long, False, 0), ((), IcePy._t_bool, False, 0)), (), ((), _M_omero.api._t_IObjectList, False, 0), (_M_omero._t_ServerError,))
    IDelete._op_checkImageDelete.deprecate(" use omero::cmd::Delete instead")
    IDelete._op_previewImageDelete = IcePy.Operation('previewImageDelete', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_long, False, 0), ((), IcePy._t_bool, False, 0)), (), ((), _M_omero.api._t_IObjectList, False, 0), (_M_omero._t_ServerError,))
    IDelete._op_previewImageDelete.deprecate(" use omero::cmd::Delete instead")
    IDelete._op_deleteImage = IcePy.Operation('deleteImage', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_long, False, 0), ((), IcePy._t_bool, False, 0)), (), None, (_M_omero._t_ApiUsageException, _M_omero._t_ValidationException, _M_omero._t_SecurityViolation, _M_omero._t_ServerError))
    IDelete._op_deleteImage.deprecate(" use omero::cmd::Delete instead")
    IDelete._op_deleteImages = IcePy.Operation('deleteImages', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), _M_omero.api._t_LongList, False, 0), ((), IcePy._t_bool, False, 0)), (), None, (_M_omero._t_ApiUsageException, _M_omero._t_ValidationException, _M_omero._t_SecurityViolation, _M_omero._t_ServerError))
    IDelete._op_deleteImages.deprecate(" use omero::cmd::Delete instead")
    IDelete._op_deleteImagesByDataset = IcePy.Operation('deleteImagesByDataset', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_long, False, 0), ((), IcePy._t_bool, False, 0)), (), None, (_M_omero._t_ApiUsageException, _M_omero._t_ValidationException, _M_omero._t_SecurityViolation, _M_omero._t_ServerError))
    IDelete._op_deleteImagesByDataset.deprecate(" use omero::cmd::Delete instead")
    IDelete._op_deleteSettings = IcePy.Operation('deleteSettings', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_long, False, 0),), (), None, (_M_omero._t_ServerError,))
    IDelete._op_deleteSettings.deprecate(" use omero::cmd::Delete instead")
    IDelete._op_deletePlate = IcePy.Operation('deletePlate', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), IcePy._t_long, False, 0),), (), None, (_M_omero._t_ServerError,))
    IDelete._op_deletePlate.deprecate(" use omero::cmd::Delete instead")
    IDelete._op_availableCommands = IcePy.Operation('availableCommands', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (), (), ((), _M_omero.api.delete._t_DeleteCommands, False, 0), (_M_omero._t_ServerError,))
    IDelete._op_availableCommands.deprecate(" use omero::cmd::Delete instead")
    IDelete._op_queueDelete = IcePy.Operation('queueDelete', Ice.OperationMode.Normal, Ice.OperationMode.Normal, True, None, (), (((), _M_omero.api.delete._t_DeleteCommands, False, 0),), (), ((), _M_omero.api.delete._t_DeleteHandlePrx, False, 0), (_M_omero._t_ApiUsageException, _M_omero._t_ServerError))
    IDelete._op_queueDelete.deprecate(" use omero::cmd::Delete instead")

    _M_omero.api.IDelete = IDelete
    del IDelete

    _M_omero.api.IDeletePrx = IDeletePrx
    del IDeletePrx

# End of module omero.api

__name__ = 'omero'

# End of module omero
